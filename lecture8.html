<!DOCTYPE html>
<!--
	Web 2.0, CTU course slides
	(cc) 2010-2013 Tomas Vitvar, tomas@vitvar.com
-->
<html>   
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
        <meta name="course"   content="Web 2.0"/>
		<meta name="lecture"  content="Lecture 8"/>
   		<meta name="keywords" content="polling, long-polling, WebSockets, new I/O"/>
           
        <link type="text/css" rel="stylesheet" href="css/meta.css"></link>   
        <link type="text/css" rel="stylesheet" href="css/ctu-fit.css"></link>   
        <link type="text/css" rel="stylesheet" href="humla/lib/core/humla.css"></link>   

        <script type="text/javascript" src="humla/lib/humla.js"></script>
        <title>Protocols for the Realtime Web</title>
	</head>
	<body> 
    
		<footer>
			<p><b>#META_LECTURE#: #TITLE#</b>,&nbsp;<span class="meta_semester"/>,&nbsp;
			<span class="meta_twitter"/></p>
			<p><b>&#8210; #SLIDE_NO# &#8210;</b></p>
		</footer>

    	<div class="slide intro">
			<hgroup>
				<h1><span class="meta_course"/></h1>
 				<h2>#META_LECTURE#: #TITLE#</h2>
			</hgroup>
			<div class="author">
				<p class="meta_author"/>
				<p><span class="meta_email"/> &bull; <span class="meta_twitter"/> &bull; 
				<span class="meta_web"/></p>
			</div>
			<center><div class="meta_logo"></div></center>
			<div class="org">
				<p class="meta_org"/>
				<p><span class="meta_orgfac"/> &bull; <span class="meta_field"/> 
				&bull; <span class="meta_orgweb"/></p>
			</div>
			<div class="etc">
        		<div class="text-info">
    				Modified: #LAST_MODIFIED#<br/>
					Humla v#HUMLA_VERSION#
				</div>
				<a href="http://creativecommons.org/licenses/by-sa/3.0/"><div class="license"></div></a>
				<div class="oppa"></div>
			</div>
		</div>
		
        <div class="slide outline"></div>		

		<section>
			<header>Long-polling and Streaming</header>

			<div class="slide">
				<hgroup>
					<h1>Pushing and Polling</h1>
				</hgroup>
				<div id="1TXuRmtQIG5wJtioixp-dizSX_TguDBJwE5WoYpCyQnE" class="h-drawing"
				  style="height: 200px"></div>
				<ul class="xx-small">
					<li>Conceptual basis in messaging architectures</li>
					<ul>
						<li>event-driven architectures (EDA)</li>
					</ul>
					<li><b>HTTP is a request-response protocol</b></li>
					<ul>
						<li>response cannot be sent without request</li>
						<li>server cannot initiate the communication</li>
					</ul>
					<li><b>Polling</b> &ndash; client periodically checks for updates on the server</li>
					<li><b>Pushing</b> &ndash; updates from the server (also called COMET)<br/>
					= <b>long polling</b> &ndash; server holds the request for some time<br/>
					= <b>streaming</b> &ndash; server sends updates without closing the socket</li>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>HTTP Long Polling</h1>
				</hgroup>
				<div id="1-YIqxkEw22GP7dIa0uqKbEpVzuCQt8yeJLMhiFiPGrs" class="h-drawing" 
				  style="height: 280px"></div>
				<ul class="xx-small">
					<li>Server holds long-poll requests</li>
					<ul>
						<li>server responds when an event or a timeout occurs</li>
						<li>saves computing resources at the server as well as network resources</li>
						<li>can be applied over HTTP persistent and non-persistent communication</li>
					</ul>
					<li>Issues:</li>
					<ul>
						<li>maximum time of the request processing at the server (e.g. GAE)</li>
						<li>concurrent requests processing at the server</li>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>HTTP Streaming</h1>
				</hgroup>
				<div id="1j6nE63Ed5zVDIgUVJeool8t9mWHtPsrs8e356Wc0b3E" class="h-drawing"
					style="height: 280px"></div>
				<ul class="xx-small">
					<li>server deffers the response until an event or timeout is available</li>
					<li>when an event is available, server sends it back to client as part of 
					the response; this does not terminate the connection</li>
					<li>server is able to send pieces of response w/o terminating the conn.</li>
					<ul>
						<li>using <code>transfer-encoding</code> header in HTTP 1.1</li>
						<li>using End of File in HTTP 1.0<br/>
							(server omits <code>content-lenght</code> in the response)</li>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Chunked Response</h1>
				</hgroup>
				<ul class="x-small">
					<li>Transfer encoding <code>chunked</code></li>
					<ul>
						<li>It allows to send multiple sets of data over a single connection</li>
						<li>a chunk represents data for the event</li> 
						<pre class="brush: plain">
						HTTP/1.1 200 OK
						Content-Type: text/plain
						Transfer-Encoding: chunked

						25
						This is the data in the first chunk 

						1C
						and this is the second one 

						0</pre>
						<li>Each chunk starts with hexadecimal value for length</li>
						<li>End of response is marked with the chunk length of 0</li>
					</ul>
					<li>Steps:</li>
					<ul>
						<li>server sends HTTP headers and the first chunk (step 3)</li>
						<li>server sends second and subsequent chunk of data (step 4)</li>
						<li>server terminates the connection (step 5)</li>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Issues with Chunked Response</h1>
				</hgroup>
				<ul class="small">
					<li>Chunks vs. Events</li>
					<ul>
						<li>chunks cannot be considered as app messages (events)</li>
						<li>intermediaries maight "re-chunk" the message stream<br/>
						&rarr; e.g., combining different chunks into a longer one</li>
					</ul>
					<li>Client Buffering</li>
					<ul>
						<li>clients may buffer all data chunks before they make the response
						available to the client application</li>
					</ul>
					<li>HTTP streaming in browsers</li>
					<ul>
						<li>Server-sent events</li>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Server-Sent Events</h1>
				</hgroup>
				<ul class="x-small">
					<li>W3C specification</li>
					<ul>
						<li>part of HTML5 specs, see <span id="w3c-sse" class="h-ref"></span></li>
						<li>API to handle HTTP streaming in browsers by using DOM events</li>
						<li>transparent to underlying HTTP streaming mechanism</li>
						<ul>
							<li>can use both chunked messages and EOF</li>
						</ul>
						<li>same origin policy applies</li>
					</ul>
					<li><code>EventSource</code> interface</li>
					<ul>
						<li>event handlers: <code>onopen</code>, <code>onmessage</code>, <code>onerror</code></li>
						<li>constructor <code>EventSource(url)</code> &ndash; creates and opens the stream</li>
						<li>method <code>close()</code> &ndash; closes the connection</li>
						<li>attribute <code>readyState</code></li>
						<ul>
							<li><code>CONNECTING</code> &ndash; The connection has not yet been established, or it was 
								closed and the user agent is reconnecting.</li>
							<li><code>OPEN</code> &ndash; The user agent has an open connection and is dispatching 
								events as it receives them.</li>
							<li><code>CLOSED</code> &ndash; The conn. is not open, the user agent is not 
								reconnecting.</li>
						</ul>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Example</h1>
				</hgroup>
				<ul class="x-small">
					<li>Initiating <code>EventSource</code></li>
					<pre class="brush: javascript; class-name: 'tight'">
					if (window.EventSource != null) {
					  var source = new EventSource('your_event_stream.php');
					} else {
					  // Result to xhr polling :(
					}</pre>
					<li>Defining event handlers</li>
					<pre class="brush: javascript">
					source.addEventListener('message', function(e) {
					  // fires when new event occurs, e.data contains the event data
					}, false);
					
					source.addEventListener('open', function(e) {
					  // Connection was opened
					}, false);
					
					source.addEventListener('error', function(e) {
					  if (e.readyState == EventSource.CLOSED) {
						// Connection was closed
					  }
					}, false);</pre>
					<ul class="small">
						<li>when the conn. is closed, the browser reconnects every ~3 seconds</li>
						<ul>
							<li>can be changed using <code>retry</code> attribute in the message data</li>
						</ul>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Event Stream Format</h1>
				</hgroup>
				<ul class="x-small">
					<li>Format</li>
					<ul>
						<li>response's <code>content-type</code> must be <code>text/event-stream</code></li>
						<li>every line starts with <code>data:</code>, event message terminates with 2 <code>\n</code> chars.</li>
						<li>every message may have associated <code>id</code> (is optional)</li>
						<pre class="brush: plain">
						id: 12345\n
						data: first line\n
						data: second line\n\n</pre>
					</ul>
					<li>JSON data in multiple lines of the message</li>
					<ul>
						<pre class="brush: plain">
						data: {\n
						data: "msg": "hello world",\n
						data: "id": 12345\n
						data: }\n\n</pre>
					</ul>
					<li>Changing the reconnection time</li>
					<ul>
						<li>default is 3 seconds</li>
						<pre class="brush: plain">
						retry: 10000\n
						data: hello world\n\n</pre>					
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Server-side implementation</h1>
				</hgroup>
				<ul class="x-small">
					<li>Java Servlet</li>
					<ul>
						<li>method <code>doGet</code></li>
					</ul>
					<pre class="brush: java">
					public void doGet(HttpServletRequest req, HttpServletResponse resp)
					    throws IOException {
					
					    // set http headers
					    resp.setContentType("text/event-stream");
					    resp.setHeader("cache-control", "no-cache");
					
						// current time in milliseconds
					    long ms = System.currentTimeMillis(); 

					    // push data to the client for 20 seconds
					    // client should reconnect when the connection is closed
					    while (System.currentTimeMillis() - ms < 20000) {
					        resp.getWriter().print("data: servlet runs for " + 
					            (System.currentTimeMillis() - ms)/1000 + " seconds.\n\n");
					        resp.getWriter().flush();
					        try {
					            Thread.sleep(4000);
					        } catch (InterruptedException e) {
					            // do nothing;
					        }
					    }
					}</pre>
				</ul>
			</div>

			<!--<div class="slide">
				<hgroup>
					<h1>Demo</h1>
				</hgroup>
				<ul>
					<li>Example Server-sent events demo</li>
					<ul class="small" style="zoom: 0.9; margin-bottom: 20px">
						<li>requires a server running at <code style="zoom: 0.9">http://demo-sse.vitvar.com:8080</code></li>
						<li>runs in <code>iframe</code>, same origin policy applies</li>
						<li>call <code>http://demo-sse.vitvar.com:8080/echo?msg=text</code>,<br/>
						&rarr; the message should be displayed as event</li>
					</ul>
					<input id="btn" type="button" onclick="javascript:run_stop_demo()" value="Run Demo"></input>&nbsp;
					<input type="button" onclick="javascript:generateEvent()" value="Generate Event"></input>
					<input id="event" type="text" value="sample text" style="width: 300px"></input><br/>
					
					<script>
						var demoURL = "http://demo-sse.vitvar.com:8080";
						
						function run_stop_demo() {
							fr = document.getElementById("if-sse");
							bt = document.getElementById("btn");
							if (bt.value == "Run Demo") {
								fr.src = demoURL;
								bt.value = "Stop Demo";
							} else {
								fr.src = "";
								bt.value = "Run Demo";
							}
						}
						
						function generateEvent() {
							fr = document.getElementById("if-gev");
							fr.src = demoURL + "/echo?msg=" + document.getElementById("event").value;
						}
						
					</script>
					
					<iframe id="if-sse" style="width: 620px; margin-top: 10px; height: 270px; 
					  border: 1px solid silver"></iframe>
					<iframe id="if-gev" style="display: none"></iframe>
			</div>-->
			
			<div class="slide">
				<hgroup>
					<h1>Other Technologies</h1>
				</hgroup>
				<ul class="x-small">
					<li>Cross-document messaging</li>
					<div id="1DRm9FfN_CyiaYCccFkFOrcygsrwF_cpy7gKg6gEscEU" 
						style="height: 165px" class="h-drawing"></div>
					<ul style="margin-top: 10px">
						<li>The use of Cross Document Messaging for streaming</li>
						<ul class="no-bullet">
							<li>1. The client loads a streaming resource in a hidden <code>iframe</code></li>	
							<li>2. The server pushes a JavaScript code to the <code>iframe</code></li>
							<li>3. The browser executes the code as it arrives from the server</li>
							<li>4. The embedded iframe's code posts a message to the upper document</li>
						</ul>
					</ul>
					<li>Channel API</li>
					<ul>
						<li>Google Technology for streaming API for AppEngine</li>
						<li>not based on HTTP streaming</li>
						<li>utilizes XMPP capabilities + hidden iframe at client-side</li>
					</ul>
				</ul>
			</div>
			
		</section>

        <div class="slide outline"></div>				
			
		<section>
			<header>WebSocket Protocol</header>
										
			<div class="slide">
				<hgroup>
					<h1>WebSocket</h1>
				</hgroup>
				<ul class="x-small">
					<li>Specifications</li>
					<ul>
						<li>IETF defines <span id="websocket" class="h-ref"></span></li>
						<li>W3C defines <span id="websocket-w3c" class="h-ref"></span></li>
					</ul>
					<li>Design principles</li>
					<ul>
						<li>a new protocol</li>
						<ul>
							<li>browsers, web servers, and proxy servers need to support it</li>
						</ul> 
						<li>a layer on top of TCP</li>
						<li>bi-directional communication between client and servers</li>
						<ul>
							<li>low-latency apps without HTTP overhead</li>
						</ul>
						<li>Web origin-based security model for browsers</li>
						<ul>
							<li>same origin policy, cross-origin resource sharing</li>
						</ul>
						<li>support multiple server-side endpoints</li>
					</ul>
					<li>Two phases</li>
					<ul>
						<li>Handshake &ndash; as an <b>upgrade</b> of a HTTP connection</li>
						<li>data transfer &ndash; the protocol-specific on-the-wire data transfer</li>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Handshake &ndash; Request</h1>
				</hgroup>
				<ul class="small">
					<li>Request</li>
					<ul>
						<li>client sends a following HTTP request to upgrade the connection to WebSocket</li>
						<pre class="brush: plain">
						GET /chat HTTP/1.1
						Host: server.example.com
						Upgrade: websocket
						Connection: Upgrade
						Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
						Sec-WebSocket-Origin: http://example.com
						Sec-WebSocket-Protocol: chat, superchat
						Sec-WebSocket-Version: 7</pre>
						<li><code>Connection</code> &ndash; request to upgrade the protocol</li>
						<li><code>Upgrade</code> &ndash; protocol to upgrade to</li>
						<li><code>Sec-WebSocket-Key</code> &ndash; a client key for later validation</li>
						<li><code>Sec-WebSocket-Origin</code> &ndash; origin of the request</li>
						<li><code>Sec-WebSocket-Protocol</code> &ndash; list of sub-protocols that client supports (proprietary)</li>
					</ul>					
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Handshake &ndash; Response</h1>
				</hgroup>
				<ul class="xx-small">
					<li>Response</li>
					<ul>
						<li>server accepts the request and responds as follows</li>
						<pre class="brush: plain">
						HTTP/1.1 101 Switching Protocols
						Upgrade: websocket
						Connection: Upgrade
						Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
						Sec-WebSocket-Protocol: chat</pre>
						<ul>
						<li><code>101 Switching Protocols</code> &ndash; status code for a successful upgrade</li>
						<li><code>Sec-WebSocket-Protocol</code> &ndash; a sub-protocol that the server selected 
							from the list of protocols in the request</li>
						<li><code>Sec-WebSocket-Accept</code> &ndash; a key to prove it has received a client 
							WebSocket handshake request (to prevent an attacker from tricking the server by sending 
							it carefully-crafted packets using XHR)</li>
						</ul>
						<li>Formula to compute <code>Sec-WebSocket-Accept</code></li>
						<pre class="brush: plain">
						Sec-WebSocket-Accept = Base64Encode(SHA-1(Sec-WebSocket-Key + 
						  "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))</pre>
						<ul>
						<li><code>SHA-1</code> &ndash; hashing function</li>
						<li><code>Base64Encode</code> &ndash; Base64 encoding function</li>
						<li><code>"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</code> &ndash; magic number</li>
						</ul>
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>Data Transfer</h1>
				</hgroup>
				<ul class="small">
					<li>After successful handshake</li>
					<ul>
						<li>socket between the client and the "resource" at the server is established</li>
						<li>client and the server can both read and write from/to the socket</li>
						<li>No HTTP headers overhead</li>
					</ul>
					<li>Data Framing</li>
					<ul>
						<li>defines a format for data transmitted in TCP packets</li>
						<li>payload length, closing frame, ping, pong,<br/>type of data (text/binary), etc. and payload (message data)</li>  
					</ul>
				</ul>
			</div>

			<div class="slide">
				<hgroup>
					<h1>WebSocket API</h1>
				</hgroup>
				<ul class="xx-small">
					<li>Client-side API</li>
					<ul>
						<li>clients to utilize WebSocket, supported by Chrome, Safari</li>
						<li>Hides complexity of WebSocket protocol for the developer</li>
					</ul>
					<li>JavaScript example</li>
					<pre class="brush: javascript; class-name: tight">
					// ws is a new URL schema for WebSocket protocol; 'chat' is a sub-protocol
					var connection = new WebSocket('ws://server.example.org/chat', 'chat');

					// When the connection is open, send some data to the server
					connection.onopen = function () {
					  // connection.protocol contains sub-protocol selected by the server
					  console.log('subprotocol is: ' + connection.protocol); 
					  connection.send('data'); 
					};
					
					// Log errors
					connection.onerror = function (error) {
					  console.log('WebSocket Error ' + error);
					};
					
					// Log messages from the server
					connection.onmessage = function (e) {
					  console.log('Server: ' + e.data);
					};
					
					...
					
					// closes the connection
					connection.close()</pre>
				</ul>
			</div>
			
			<div class="slide">
				<hgroup>
					<h1>Sockets.IO</h1>
				</hgroup>
				<ul class="x-small spacing">
					<li>Many options for streaming</li>
					<ul>
						<li>long-polling, streaming, iframe, WebSockets</li>
						<li>Not all browsers support WebSockets</li>
						<li><span id="socket.io" class="h-ref"></span> &ndash; a layer providing a unified API</li> 
					</ul>
					<li>Sockets.IO</li>
					<ul>
						<li>API and JavaScript implementation</li>
						<li>checks the availability of WebSocket protocol</li>
						<ul>
							<li>fallback to long-polling or other technologies when not available</li>
						</ul>
					</ul>
					<pre class="brush: javascript">
					// creates a new socket
					var socket = new io.Socket(); 
					
					// event handlers
					socket.on('connect', function(){ 
					  socket.send('hi!'); 
					}) 
					socket.on('message', function(data){ 
					  alert(data);
					})
					socket.on('disconnect', function(){})</pre>
				</ul>
			</div>
			
		</section>

        <div class="slide outline"></div>		
		
		<section> 
			<header>New I/O Model</header> 
			
			<div class="slide"> 
				<hgroup> 
					<h1>Highly Scalable Web Servers</h1> 
				</hgroup> 
				<ul class="small"> 
					<li>Concurrent connections</li> 
					<ul> 
						<li>servers must serve a huge amount of concurrent connections</li> 
						<li>Highly scalable Web apps</li>
						<ul> 
							<li>many concurrent requests at the same time</li>
							<li>QPS: 10-100 or more (GAE scales up to 500 QPS)</li>
						</ul> 
						<li>more significant with new trends regarding streaming (HTTP and WebSocket)</li> 
					</ul> 
					<li>Web server implementation models:<br/><b>Synchronous I/O vs. Asynchronous I/O</b></li> 
					<ul> 
						<li>synchronous I/O (aka blocking I/O)</li>
						<ul> 
							<li>traditional: server creates a thread for every connection</li>
						</ul> 
						<li>asynchronous I/O (aka non-blocking I/O)</li>
						<ul> 
							<li>new one, server handles processing of requests separately from incoming connections</li>
					 	</ul>
					</ul> 
				</ul> 
			</div> 
			
			<div class="slide">
				<hgroup> 
					<h1>Web App Scalability</h1> 
				</hgroup> 
				<div id="1WhfN-7eM4bNeyBSbxir8d0Fk6kW1yt2-yH4l8TSUH5Q" 
					style="height: 400px; margin-top: 40px" class="h-drawing"></div>
			</div>
 
			<div class="slide"> 
				<hgroup> 
					<h1>Synchronous I/O Model</h1> 
				</hgroup> 
				<div id="1QP7gZSS1WS3YquzLekSgdZfcmi4BYArm-K9tuWrULQs" class="h-drawing" style="height: 220px"></div>
				<ul class="xx-small">
					<li>every request served by a single thread</li>
					<ul>
						<li>reserved for the whole processing, the thread is "blocked"</li>
					</ul>
					<li>when processing of the request is fast, scales well</li>
					<ul>
						<li>OS maintains a pool of threads that are reused for new requests</li>
					</ul>
					<li>when processing of the request requires other interactions with DB/FS or network 
						communication is slow &rarr; scaling is bad</li>
					<ul>
						<li>more significant with streaming (long polling or HTTP streaming)</li>
					</ul>
					<li>OS may create couple of hundreds of threads (~1000 is very large)</li>
					<ul>
						<li>app may serve over 1K clients easily</li>
					</ul>
				</ul>
			</div>

			<div class="slide"> 
				<hgroup> 
					<h1>Asynchronous I/O Model</h1> 
				</hgroup> 
				<div id="1Wp3tMx_L6L8lesjNQ6YhFgEVY_xN1-cLyh-ZZ32H_WQ" class="h-drawing" style="height: 220px"></div>
				<ul class="xx-small">
					<li>requests/connections maintained by the OS</li>
					<li>Web server reacts on the events</li>
					<ul>
						<li>such as new socket, read, write</li>
						<li>it may create a working thread to perform required processing</li>
						<li>Web server may control the number of Worker Threads</li>
					</ul>
					<li>significantly less number of working threads as opposed to blocking I/O</li>
				</ul>
			</div>

			<div class="slide"> 
				<hgroup> 
					<h1>Performance Experiment</h1> 
				</hgroup> 
				<center><figure style="zoom: 0.9"><img style="margin: 20px 20px 0px 20px" src="img/l12/graph-nio-tomcat.gif"></img>
				<figcaption style="width: 80%">Non-blocking vs. blocking performance (number of 
					requests per second served by the server vs. number of users), source 
				  <span class="h-ref" id="nio-peformance"></span></figcaption></figure></center>
				<ul class="xx-small" style="margin-top: 15px">
					<li>Tomcat &ndash; Java-based, uses I/O blocking communication</li>
					<ul>
						<li>configured to run up to 2,000 threads</li>
					</ul>
					<li>NIO &ndash; a Web server implemented using Java.NIO (Java New I/O)</li>
					<ul>
						<li>only 4 working threads</li>
					</ul>
					<li>simple HTTP <code>GET</code> serving textual content</li>
				</ul>
			</div>

			<div class="slide"> 
				<hgroup> 
					<h1>Emerging Technologies</h1> 
				</hgroup>
				<ul class="x-small">
					<li>Node.js</li>
					<ul>
						<li><span id="nodejs" class="h-ref"></span> &ndash; event-driven I/O framework on JavaScript V8 engine</li>
						<ul>
							<li>every I/O as event:</li>
						</ul>
						<pre class="brush: javascript">
						// pseudo code; ask for the last edited time of a file
						stat( 'somefile', function( result ) {
						  // use the result here
						} );
						...
						
						// web server
						var http = require('http');
						http.createServer(function (req, res) {
						  res.writeHead(200, {'Content-Type': 'text/plain'});
						  res.end('Hello World\n');
						}).listen(8080, "127.0.0.1");
						console.log('Server running at http://127.0.0.1:8080/');</pre>
						<li>runs in Linux/Unix/OS X environments</li>
						<li>Executes your server-side JavaScript code</li>
						<li>Socket.IO as a modul provides a streaming layer</li>
					</ul>
					<li>Java.NIO</li>
					<ul>
						<li>Java New I/O, standard in Java SE 7</li>
					</ul>
					
				</ul>
			</div>
 
		</section>			
		

		
		
		
		
	</body>
</html>	
